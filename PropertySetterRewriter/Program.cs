using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;

namespace PropertySetterRewriter
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string code = File.ReadAllText(args[0]);
            var tree = CSharpSyntaxTree.ParseText(code);
            var root = tree.GetRoot();

            // Create a new comment syntax node indicating that the file is auto-generated
            SyntaxTrivia autoGeneratedComment = SyntaxFactory.Comment(
                $@"
//----------------------
// <auto-generated>
//     This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild
// </auto-generated>
//----------------------
");

            // Add the comment to the leading trivia of the root node
            root = root.WithLeadingTrivia(autoGeneratedComment);

            var rewriter = new AddSetterRewriter();
            var newRoot = (SyntaxNode)rewriter.Visit(root);
            // Format the code
            newRoot = Formatter.Format(newRoot, new AdhocWorkspace());

            // Format the code
            var workspace = new AdhocWorkspace();
            var options = workspace.Options.WithChangedOption(FormattingOptions.NewLine, LanguageNames.CSharp, "\r\n"); // Use Carriage Return + Line Feed (CRLF)
            var formattedNode = Formatter.Format(newRoot, workspace, options);

            var newCode = formattedNode.ToFullString();

            File.WriteAllText(args[1], newCode);
        }
    }

    public class AddSetterRewriter : CSharpSyntaxRewriter
    {
        public override SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
        {
            // Add a new parameter of type bool with default value false
            var newParameter = SyntaxFactory.Parameter(SyntaxFactory.Identifier("write"))
                .WithType(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(SyntaxKind.BoolKeyword).WithTrailingTrivia(SyntaxFactory.Space)))
                .WithDefault(
                    SyntaxFactory.EqualsValueClause(SyntaxFactory.LiteralExpression(SyntaxKind.FalseLiteralExpression)));

            // Add the new parameter to the existing parameter list
            var newParameterList = node.ParameterList.AddParameters(newParameter);

            // Find the existing _read() call statement
            var oldStatement = node.Body.Statements
                .FirstOrDefault(
                    s => s is ExpressionStatementSyntax es &&
                         es.Expression is InvocationExpressionSyntax ie &&
                         ie.Expression is IdentifierNameSyntax ina &&
                         ina.Identifier.Text == "_read");

            // Create a new if statement that checks the value of the write parameter
            var ifStatement = SyntaxFactory.IfStatement(
                SyntaxFactory.PrefixUnaryExpression(
                    SyntaxKind.LogicalNotExpression,
                    SyntaxFactory.IdentifierName("write")),
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("_read"))));

            // Replace the old statement with the new if statement
            var newBody = node.Body.ReplaceNode(oldStatement, ifStatement);

            // Modify assignments to boolean fields that start with "f_"
            var statements = newBody.Statements
                .Select(statement =>
                {
                    if (statement is ExpressionStatementSyntax expressionStatement &&
                        expressionStatement.Expression is AssignmentExpressionSyntax assignment &&
                        assignment.Left is IdentifierNameSyntax identifier &&
                        identifier.Identifier.Text.StartsWith("f_") &&
                        assignment.Right is LiteralExpressionSyntax literal &&
                        literal.Token.Value is bool)
                    {
                        return statement.ReplaceNode(literal, SyntaxFactory.IdentifierName("write"));
                    }

                    return statement;
                });

            newBody = newBody.WithStatements(SyntaxFactory.List(statements));

            // Return a new constructor declaration with the new parameter list and body
            return node.WithParameterList(newParameterList).WithBody(newBody);
        }

        public override SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)
        {
            if (node.Identifier.Text.ToLower().Contains("uint".ToLower()))
            {
                return node.WithBaseList(
                    SyntaxFactory.BaseList(
                        SyntaxFactory.SingletonSeparatedList<BaseTypeSyntax>(
                            SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName("uint")))))
                    .WithLeadingTrivia(node.GetLeadingTrivia())
                    .WithTrailingTrivia(node.GetTrailingTrivia());
            }
            return node;
        }

        public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
        {
            // Check if the property has a public accessor
            if (node.Modifiers.Any(SyntaxKind.PublicKeyword))
            {
                // Get the name of the property
                var propertyName = node.Identifier.ValueText;

                // Get the name of the private backing field
                var fieldName = $"_{char.ToLower(propertyName[0])}{propertyName.Substring(1)}";

                if (propertyName == "M_Root")
                    fieldName = "m_root";

                if (propertyName == "M_Parent")
                    fieldName = "m_parent";

                if (propertyName == "M_RawBody")
                    fieldName = "__raw_body";

                // Create a setter accessor with an assignment statement
                var setter = SyntaxFactory.AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                    .WithBody(
                        SyntaxFactory.Block(
                            SyntaxFactory.ExpressionStatement(
                                SyntaxFactory.AssignmentExpression(
                                    SyntaxKind.SimpleAssignmentExpression,
                                    SyntaxFactory.IdentifierName(fieldName),
                                    SyntaxFactory.IdentifierName("value")))));

                // Add the setter to the existing accessors list
                var accessors = node.AccessorList.AddAccessors(setter);

                // Return the modified property declaration with the new accessor list
                return node.WithAccessorList(accessors);
            }

            // Otherwise, return the original node
            return node;
        }
    }
}